GNL -> STRJOIN (NULL, LINE[FD])

INIT_STRUCT :
->inializar com 0's a struct;

CHECK_MAP_NAME :
->pointeiro valido  -> feito
->falha abrir, fd (invalid fd) -> FEITO
-> ficheiro que nao seja .ber -> FEITO
->fechar fds -> feito

GET_LINES :
->ponteiro valido, ou struct -> feito
-> fd invalido, ou nenhum ->  feito
-> fd invalido em gnl -> feito
->fechar fds -> feito

GET_MAP :
->pointers validos -> feito
-> verificar altura (se for <= 0) da erro -> feito;
-> fd invalido -> feito
-> falha no malloc -> feito
-> fd invalido gnl -> feito 
-> Null pointer strdup -> feito;
-> diferenca de i(altura calculada no loop) para map.height -> feito

CHECK_VALID_MAP :
    -> checkar pointers validos -> leaks quando !data;
        possivel solucao (passar funcao para int);
        ->CHECK_FORMAT :
            ->pointers validos -> feito;
            -> enquanto i for menor que height -> feito
        -> VALID CHARS :
            -> checkar pointers validos -> feito;

        -> CHECK_WALLS :
            -> checkar pointers validos -> feito;
        -> CHECK_COLLECTIBLES :
            -> checkar pointers validos -> feito;
        -> CHECK_START_POS :
            -> checkar pointers validos -> feito;
        -> CHECK_EXIT :
            -> checkar pointers validos -> feito;
        -> CHECK_VALID_PATH :
            -> checkar pointers validos -> feito;
            ->checkar se a copia retorna null -> feito;
                ->COPY_MAP :
                    -> ponteiros validos e altura valida -> feito;
                    -> falha malloc -> feito;


FT_STRDUP :
    -> ponteiros validos -> feito;
    ->falha malloc -> feito;
    -> passagem de invalid pointer p strdup -> feito

GNL :
    -> veificar strjoin(null, line[fd]) leaks -> por fazer
        (possivel solucao):
            -> usar strdup quando !s1
            -> caso !s1 && !s2 retunr (NULL);
            -> caso !s2 dar free em s1 e retornar null;

ERRORS :
    ->EXIT_ERROR:
        ->pointers invalidos -> feito
            -> se a !struct, nao liberta memoria, escreve msg de erro ->feito;
            ->se !str, retorna uma msg de erro default;
        ->fechar fds -> feito;
        -> flag para verificar se ja levou free -> feito;
        -> free em map se a struct e map forem validos -> feito;
        -> caso nao tenha sido liberto, flag =  0, libertar struct -> feito;
        -> msg de erro personalizada -> feito;
        -> exit -> feito;

UTILS :
    -> CLOSE_FDS :
        -> i = 3 -> 1ยบ fd disponivel -> feito;
    -> FREE_ARR :
        -> pointers validos -> feito;
        -> libertar enquanto i < height , verificar validade de arr -> feito;
        -> libertar arr -> feito;
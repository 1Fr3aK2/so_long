GNL -> STRJOIN (NULL, LINE[FD])

INIT_STRUCT :
->inializar com 0's a struct; -> feito;

CHECK_MAP_NAME :
->pointeiro valido  -> feito
->falha abrir, fd (invalid fd) -> FEITO
-> ficheiro que nao seja .ber -> FEITO
->fechar fds -> feito

GET_LINES :
->ponteiro valido, ou struct -> feito
-> fd invalido, ou nenhum ->  feito
-> fd invalido em gnl -> feito
->fechar fds -> feito

GET_MAP :
->pointers validos -> feito
-> verificar altura (se for <= 0) da erro -> feito;
-> fd invalido -> feito
-> falha no malloc -> feito
-> fd invalido gnl -> feito 
-> Null pointer strdup -> feito;
-> diferenca de i(altura calculada no loop) para map.height -> feito

CHECK_VALID_MAP :
    -> checkar pointers validos -> leaks quando !data;
        possivel solucao (passar funcao para int);
        ->CHECK_FORMAT :
            ->pointers validos -> feito;
            -> enquanto i for menor que height -> feito
        -> VALID CHARS :
            -> checkar pointers validos -> feito;
        -> CHECK_WALLS :
            -> checkar pointers validos -> feito;
        -> CHECK_COLLECTIBLES :
            -> checkar pointers validos -> feito;
        -> CHECK_START_POS :
            -> checkar pointers validos -> feito;
        -> CHECK_EXIT :
            -> checkar pointers validos -> feito;
        -> CHECK_VALID_PATH :
            -> checkar pointers validos -> feito;
            ->checkar se a copia retorna null -> feito;
            ->checkat se flood_fill_map retorna erro -> feito;
                ->COPY_MAP :
                    -> ponteiros validos e altura valida -> feito;
                    -> falha malloc -> feito;
                -> FLOOD_FILL_MAP
                    ->verificar ponteiros válidos e coordenadas validas -> feito;


FT_STRDUP :
    -> ponteiros validos -> feito;
    ->falha malloc -> feito;
    -> passagem de invalid pointer p strdup -> feito

GNL :
    -> veificar strjoin(null, line[fd]) leaks -> por fazer
        (possivel solucao):
            -> usar strdup quando !s1
            -> caso !s1 && !s2 retunr (NULL);
            -> caso !s2 dar free em s1 e retornar null;

ERRORS :
    ->EXIT_ERROR:
        ->pointers invalidos -> feito
            -> se a !struct, nao liberta memoria, escreve msg de erro ->feito;
            ->se !str, retorna uma msg de erro default;
        ->fechar fds -> feito;
        -> flag para verificar se ja levou free -> feito;
        -> free em map se a struct e map forem validos -> feito;
        -> caso nao tenha sido liberto, flag =  0, libertar struct -> feito;
        -> msg de erro personalizada -> feito;
        -> exit -> feito;

UTILS :
    -> CLOSE_FDS :
        -> i = 3 -> 1º fd disponivel -> feito;
    -> FREE_ARR :
        -> pointers validos -> feito;
        -> libertar enquanto i < height , verificar validade de arr -> feito;
        -> libertar arr -> feito;


STRUCT_PLAYER:
    -> int x -> linhas(width);
    -> int y -> altura(height);

STRUCT_MAP :
    -> exit_y = coordenada (altura) da saida;
    -> exit_x = coordenada (linha) da saida;

MELHORAR ESTRUTURA PLAYER, ACRESCENTAR COORDENADAS DE SAIDA ??? 



/* static int flood_fill_map(char **map, int y, int x)
{
	t_map *map_origin;
	int collectibles;
	int	exit;

	exit = 0;
	collectibles = 0;
	if (!map || x < 1 || y < 1)
		return (-1);
	if (map[y][x] == WALLS || map[y][x] == '2')
		return 1;
	exit = map_origin->exit;
	collectibles = map_origin->collectibles;
	if (map[y][x] == COLLECTIBLE)
		collectibles--;
	if (map[y][x] == EXIT)
	{
		exit--;
		if (exit != 0)
			return (-1);
		return 1;
	} 
	map[y][x] = '2';
	flood_fill_map(map, y - 1, y);
	flood_fill_map(map, y + 1, y);
	flood_fill_map(map, y, x + 1);
	flood_fill_map(map, y, x - 1);
	return (1);
} 


static void flood_fill(char **map, t_data *data)
{
	if (!map || !data)
		return ;
	if (data->map.collectibles != 0 || data->map.exit !=)
	
} */
int check_valid_path(t_map *map, t_temp_map *temp_map)
{
	/*t_temp_map temp_map; */
	if (!map || !temp_map)
		return (-1);
	temp_map->map = copy_map(map->map, map->height);
	if (!temp_map->map)
		return (-1);
	printf("MAPA: \n\n");
	for (int j = 0; j < map->height; j++)
	{
		if (temp_map->map[j]) 
			write(1, temp_map->map[j], ft_strlen(temp_map->map[j]));
	}
	/* if (flood_fill_map(temp_map->map, altura, width) != 1)
	{
		printf("FLOOD_FILL ERROR\n");
		return (-1);
	} */
	printf("\n\nFIM!\n");
	free_arr(temp_map->map, map->height);
	return 1;
}